%%
%%  Example paper
%%
%%

%%%%%%%%%%%%%%%%%% Usenix style %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[10pt,twocolumn,a4paper]{article}
\usepackage{styles/usenix-style}

\author{Jean Diestl}

%%%%%%%%%%%%%%%%%% Document %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: Change draft to final before submitting final version.
\usepackage[draft]{styles/ka-style}
\usepackage{cite,xspace,ifthen,graphicx,listings,lstautogobble}

\usepackage[
   pdfauthor={Jean Diestl},
   pdftitle={Linux namespaces},
   pdfsubject={KIT testing OS Level Virtualization},
   pdfkeywords={Papers, Template}
]{hyperref}

\begin{document}

\title{Linux Namespaces: KIT testing OS Level Virtualization}

\newcommand{\todo}[1]{{\texttt{[#1]}}}
\newcommand{\code}[1]{{\tt \small{#1}}}

\maketitle
%\draftfooter
\lstset{language=C, basicstyle=\ttfamily,
        columns=fullflexible,
        string=[b]', showspaces=false, showtabs=false,
         captionpos=b,
        framerule=1pt,
        breaklines=true, breakatwhitespace=true,
        autogobble=true}


\begin{abstract}
While all operating systems virtualize hardware like memory or the cpu other resources remain shared between processes.
In kernel 2.4.19 Linux introduced the concept of namespaces to virtualize such resources. This paper will give a brief 
introduction to Linux namespaces and present KIT a tool that was developed by Congyu Liu et al. to
find bugs in those.
\end{abstract}

\section{Introduction}\label{sec:introduction}
Linux namespaces are a kernel feature that allows process isolation on the operating system level.
This allows to virtualize resources like the network stack or the process tree.
While processes in the same namespace see the modifications their peers made to system resources
processes in other namespaces do not. Unlike similar technologies namespaces were isolated with
isolation in mind. 
This feature is widely used and builds the foundation for many container technologies like podman.
KIT is a new framework developed by Congyu Liu et al. for finding interference bugs in OS level virtualization\cite{0}. 
This is done by comparing system call traces of processes with and without possible interference.
This report gives a brief introduction to the inner
workings of KIT and will also give a detailed description of one bug
that was found by KIT. 

\section{Linux Namespaces}\label{sec:background}

\subsection{usecases}
Containers create an reproducible environment that is independent of the host system with minimal overhead.
Thus, software that is run inside a container is not affected if the host system is changed, 
Container engines like docker or podman achieve this by using namespaces and other isolation technologies to build this environments.


Another usecase for namespace is sandboxing. For example Chrome and Firefox use Linux namespaces in their sandboxes. 
Chrome uses user namespaces and PID namespaces to isolate certain processes.
This is done to reduce the impact of vulnerabilities in those processes that could lead to remote code execution.


\subsection{Inner workings}
Linux knows 7 namespaces: mount, PID, net, IPC, user, UTS and cgroup namespaces. Each namespace
isolates its own set of resources. Namespaces are implemented in the Linux kernel.
Each process has a link to the namespaces it belongs to. This link can be found in
/proc/self/ns\cite{8}. The namespaces are implemented as a tree. Each namespace has a parent and 
elements in child namespaces are visible in the parent namespace, there they can show different
attributes than in their respective child namespaces. For example a process in a PID namespace might 
believe that it is pid 1 while the PID in the parent namespace is 21 and the PID in the root namespace is 42.

Linux handles namespaces via inodes. Each namespace has a corresponding inode. Processes in this
namespace link to this inode. If no links to this inode exist anymore and thus no processes are in
this namespace the namespace is destroyed. To keep a namespace alive even with no processes in it
one can bind the corresponding file to another place in the filesystem. To reference a namespace a
filedescriptor is used. The namespaces are managed by the kernel processes can use various system
calls to create new namespaces or to join existing ones.\cite{8} Following is a list of the seven
namespaces and their features.


\subsection{Process ID namespace}
The PID namespace isolates the set of process id's. 
Thus each PID namespace has a full set of PID's to use in a new network namespace the PIDs start
with one.
Processes in different PID namespaces can have the same PID in their namespace. 
Processes that are spawned in a PID namespace get a PID in the parent PID namespace as well 
\cite{11}.

\subsection{Network namespaces}
Each net namespace has it's own network stack. Therefor each net namespace has its own set of ip
addresses,firewall rules, routing tables and sockets. Physical network hardware is assigned to exactly one
net namespace and can only be used from within this namespace. Linux provides a virtual network device
pairs that can connect net namespaces.\cite{10}

\subsection{Mount namespaces}
Mount namespaces isolate the filesystem mount points. 
Each mount namespace provides a own view of the system mountpoints. 
Upon creating these views are copied from the parent or calling processes namespace.
To soften the impacts of isolation linux introduced shared subtrees. This allows the propagation of
mount and unmount events between namespaces.\cite{12}

\subsection{IPC namespaces}
IPC namespaces isolates POSIX message queues and System V IPC objects. This allows the reuse of identifiers
in different namespaces.\cite{13}

\subsection{UTS namespaces}
UTS namespaces isolate the hostname and the domainname. Upon creation the hostname and domainname are copied from the parent namespace.\cite{14}

\subsection{Time namespaces}
Time namespaces isolate the system clock. This allows different offsets for different namespaces.
Unlike other namesapces this namespace can only be created via unshare and the calling process is
not plaed inside the namespace.\cite{15}

\subsection{Cgroup namespaces}
Cgroups are a kernel feature that allows to group processes into group and monitor or limit the resource usage
of such groups. Resouces usually regulated are memory and cpu time \cite{16}. Cgroups are orgnaized
in a tree. The cgroup namespace isolates the view on this cgroup hiraechy. This means that a process
in the cgroup namespaces sees his own cgroup as the root of the cgroup tree. \cite{17}

\subsection{User namespaces}
User namespaces isolate user and group ids and permission related attributes like keyrings and
capabilities. User namespaces are nested so that all user namespaces except the root user namespace
have a parent namespace. The parent namespace is the namespace of the creating process. 
It is possible to map user and group ids in a user namespace, this means that a process in a new user
namespace can have userid 0 and groupid 0 in this namespace while not being root. The same mapping
can be done for euid and egid's as well \cite{18}. The second method the kernel uses to keep track
of permissions are capabilities. Capabilities are a way to split the privileges of root into smaller
privileges. While without capabilities a process can have root privileges and thus can do anything
or have no root privileges. With capabilities it is possible to give a process a subset of the root
privileges. For example a process that holds the CAP\_NET\_ADMIN capability can access network
operations while a process holding CAP\_KILL is permitted to send signals to other
processes\cite{19}. The probably best known capability is CAP\_SYS\_ADMIN which covers some of the
other capabilities. 
User namespaces do also isolate these capabilities. For example a process that creates a new
namespace and joins this namespace holds the CAP\_SYS\_ADMIN capability in this namespace even if he
did not before. Obviously the CAP\_SYS\_ADMIN does not grant the same privileges one would expect from
a "real" CAP\_SYS\_ADMIN but it is still enough to subvert the idea of capabilities, confuse users and
developers and even increase the attack surface of the kernel cirticized\cite{20}. 

\subsection{Namespace usage}
As already mentioned processes interact with namespaces via system calls. There exist 3 system calls
to manipulate namespaces. 
\subsection{ clone}
The clone system call creates a new child process. The child process can be placed in a new
namespace by passing the corresponding flags. This however requires the calling process to hold
CAP\_SYS\_ADMIN. For example to create a new PID namespace the CLONE\_NEWPID flag is used like this:
\begin{lstlisting}[language=C]
    int pid = clone(child_func, child_stack + STACK_SIZE, CLONE_NEWPID | SIGCHLD, NULL);
\end{lstlisting}
The pid the parent process gets is in the parent namespace and therefor different from the pid the
child process would see if it would call getpid(). (Note that clone returns pid 0 in the
child)\cite{22}.

\subsection{ setns}
If a process wants to join an existing namespace it can use the setns system call. This system call
allows a process to join a namespace by passing a file descriptor to a link of the namespace. The
process can also specify what type if namespace it wants to join by providing a flag. The
requirments for this system call depend on the provided arguments. For user namespaces the process
must hold CAP\_SYS\_ADMIN in the target namespace since it is granted CAP\_SYS\_ADMIN upon joining
regardless of its group's or users. This realisticaly means that a process can only
join descendant namespaces. Furthermore a process can not rejoin his own namespace since this would
allow to recover dropped capabilities \cite{23}. The following code snippet shows how to join the
cgroup namespace of process 42:
\begin{lstlisting}[language=C]
    int fd = open("/proc/42/ns/cgroup", O_RDONLY);
    setns(fd, CLONE_NEWCGROUP);
    //setns(fd, 0); //would join any namespace
\end{lstlisting}


\subsection{ unshare}
The unshare system call allows a process to create a new namespace and place itself in this
namespace (except for  time namespaces where childs would be placed in the namespace \cite{15}). 
The process can specify what type of namespace it wants to create by passing a flag. To create a new
UTS namespace the following code can be used:
\begin{lstlisting}[language=C]
    unshare(CLONE_NEWUTS);
\end{lstlisting}\cite{24}
\section{Related Technologies}\label{sec:related}
\subsection{chroot}
Linux knows the change root system call which changes the root directory of the calling
process. This means that the calling process and its children can not access files outside of the
new root. This is implemented in the pathname resolution\cite{1}. Chroots were not intended as
isolation technique and thus can be escaped sometimes. Linux mount namespaces are
designed as isolation tool and can achieve the same results as chroot. Besides that one can use
chroots in combination with mount namespaces\cite{1},\cite{25}. 

\subsection{SELinux and AppArmor}
SELinux and AppArmor are systems that allow the implementation of mandatory access control. In
contrast to the traditional linux access control this means that policies are enforced by the system
and can not be altered by the user. Furthermore these tools allow a more fine grained control over
access rights. This can be done to protect other processes and the system but does not allow the resource
virtualization that namespaces allow\cite{26}\cite{27}. 
\subsection{Windows containers}
Windows seems to have a similar concept to linux namespaces called process isolation. Not much is known about the
implementation. Additionally windows allows also so called hyper-v isolation, here each container
gets his own virtual machine and is run on the hypervisor\cite{3}.
\section{Namespace bug}
\subsection{Interference bugs}
Many bugs in the linux namespace implementation are semantic bugs. This means that the 
bug does not result in invaldi memory access or a crash but in wrong behavior. Functional interference bugs are
such bugs that allow processes to interfere with processes outside of their namespace. Thus
breaking isolation. This bugs are hard to detect with traditional testing methods due to the
complexity of the bugs and the complexity of the kernel itself.
\section{KIT}
KIT is a new framework for finding interference bugs in OS level virtualization\cite{0}. It was
implements a new differential approach to finding such bugs and found 9 new bugs in kernel 5.13\cite{2}.
KIT is designed as pipeline and implemented in 7600 lines of code not counting existing tools\cite{0}.
The main idea behind KIT is to check if a process behaves differently if another process is running
in parallel.
\subsection{Testcase generation}
KIT takes as input a corpus of testcases these come from other kernel fuzzers.
A KIT testcase contains to programs, one which sender who modifies a namespace protected kernel
resouce and a reciever who reads from the same resource. To find such testcases
KIT runs the input testcases in a special environment and profiles their memory access. 
After that 2 programms are paired together if they access similar memory regions with a write and
read access and the memory region belongs to an namespace protected resouce.
To reduce the number of testcases uses heuristics to group similar testcases together.


\subsection{Testcase execution}
KIT uses Qemu to run testcases in virtual machines. To avoid non deterministic behavior KIT uses
a different communication channel and reloads vm snapshots after each testcase. KIT executes a
testcase twice. The first time first the sender program is run and then the reciever program. The
systemcall trace of the reciever is collected. In the second run the sender is skipped and the reciever
is run again to collect a baseline systemcall trace\cite{0}. 
\subsection{Bug detection}
KIT keeps these systemcall traces as Abstract Syntax Trees (AST). This additional information allows 
to create minimal testcases and to filter out irrelevant systemcalls. This is done by comparing the ASTs
recursivly and ignoring children that are flagged as irrelevant. These flags are typically set when
a systemcall involves resources that are not isolated by namespaces or if the output of the
systemcall is not static. This can be foundout by rerunning the reciever multiple times and
comparing the systemcall traces. Each inner node that differs in these AST's can be flagged as non
deterministic.
After a difference is found KIT creates a minimal by differntially removing systemcalls. This
minimal testcase is then passed to the next stage\cite{0}.
\subsection{report aggregation}
The last stage of KIT is the report aggregation. This stage is important since the results will be
analyzed by humans and thus need to be reduced to a minimum to save time. KIT does this by grouping
testcases together if they have the same sender and reciever systemcalls that are responsible for
the bug\cite{0}. 

\section{Related Work}
Currently there is no comparable tool like KIT. Other tools like syzkaller\cite{4} and trinity\cite{5} are
unlikley to find such bugs ince they lack the ability to detect anomalies in the behavior of
namespace protected resources and often do not reach deep enough in the code base.
The static approach for finding interference bugs seems not feasible
since due to the complexitity of the kernel and the nature of the bugs many false positives would
be found. KIT makes use of some existing tools like syzkaller and needs existing testcases to
perform its analysis\cite{0}\cite{2}.
\section{A namespace bug}\label{sec:bug}
Personally I was not able to reproduce the bug. But
since i could not get kit to run and thus used syzkallers POC extractor I assume that the mistake
happend in the conversion from syzkaller to C code\cite{0}.
\subsection{Bug description}
The paper found 9 new bugs in the linux kernel 5.13 \cite{0}. One of these bugs is a net namespace
bug that will be described in this section. 
\subsection{Network background}
Sockets are pseudo files that serve as endpoints for communication similar to pipes. Unlike pipes
they allow duplex communication and can allow communication over networks\cite{5}. Sockets are
used to implement network protocols in user space \cite{5}. The kernel forwards the packets to the
corresponding socket. This mapping can be seen in /proc/net/ptype \cite{6}. Linux sockets are
namespace protected and thus no information about them should be shared between namespaces.

\subsection{Bug description}
Packets that are bound to devices are only showed in the namespace of the device. However if packet
types are not bound to a device they have no reference to a namespace and are shown in all network
namespaces. This allows a process to create a packet type in a network namespace and a second
process can see this packet type in a different network namespace thus breaking isolation.


\subsection{Bug reproduction}
\todo{Not much additoional information is gained since gdb does not help that much. And  kit does not
work on my machine}
\subsection{Analysis}
The responsible method can be found in net/core/net-procfs.c. The method is called ptype\_seq\_show
and here is the vulnerable code snippet:
\begin{lstlisting}{caption=vulnerable code snippet}
/*...*/
else if (pt->dev == NULL || dev_net(pt->dev) == seq_file_net(seq)) {
    /* show packet types */
\end{lstlisting}
Normally packet types are bound to a device. If this method is invoked it is checked if the device
associated with the packet type is in the same network namespace as the calling process. This is
done by comparing the network namespace of the device with the network namespace of sequence file.
However to avoid null pointer exceptions short circuiting is used to check if the device is null. If
this is the case the namespace check is skipped. The following syzcaller test case does this.
\begin{lstlisting}{caption=sender test case}
r0 = socket$packet(0x11, 0x2, 0x300)
bind$packet(r0, 
    &(0x7f0000000100)={0x11, 0xc, 0x0, 0x1, 0x0, 0x6,
    @multicast}, 0x14)
bind$packet(r0, 
    &(0x7f0000000040)={0x11, 0x7, 0x0, 0x1, 0x0, 0x6,
    @broadcast}, 0x14)
\end{lstlisting}
The leakege can be seen by reading the file /proc/net/ptype in a different network namespace for
example with cat.

\subsection{Bug fix}
The fix for this bug is adding a pointer to the network namespace that references the namespace
where the packet type was created. This pointer is then checked whenever the packet type is
viewed. A fix has been submitted.\cite{4}
The previous code snippet is changed to the following:
\begin{lstlisting}{caption=fix}
/*...*/
	else if ((!pt->af_packet_net ||  net_eq(pt->af_packet_net, seq_file_net(seq))) &&
		 (!pt->dev || net_eq(dev_net(pt->dev), seq_file_net(seq)))) {
                 /* show packet types */
\end{lstlisting}
\cite{4}
\subsection{Impact}
This bug presents a minor information leakage and is merely relevant for desktop systems.
However in an shared host enviroment this bug allows two processes to check if they run on the same
hardware. This information can be used to perform power attacks. These attacks aim to create power
outages by creating power peaks in multiple hosts at the same time. If two containers share the same
host this knowledge can decrease the cost of such attacks\cite{7}.
\section{Conclusion}
Namespaces are a powerful established way to isolate processes. They are used in many different enviroments 
and are a key component of containerization and sandboxing. Thus research in the field of namespace isolation is
imporant. KIT implements a new approach to namespace fuzzing and was able to find new bugs in the
kernel, which proves the effectiveness of this approach. It remains to be seen what differential
fuzzing can find with a custom  test corpus and further optimizations. It is currently unclear if
kit will be adopted by the community or not. That being said and the  grown interset in formal
verification in rechent years in mind one may look forward to a formal verification of the linux
kernel which seems to be the natural way of finding such logic bugs in the first place.
\bibliographystyle{abbrv}
\bibliography{template}
%\footnotesize
\end{document}
