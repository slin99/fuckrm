%%
%%  Example paper
%%
%%

%%%%%%%%%%%%%%%%%% Usenix style %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[10pt,twocolumn,a4paper]{article}
\usepackage{styles/usenix-style}

\author{Jean Diestl}

%%%%%%%%%%%%%%%%%% Document %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: Change draft to final before submitting final version.
\usepackage[draft]{styles/ka-style}
\usepackage{cite,xspace,ifthen,graphicx,listings}

\usepackage[
   pdfauthor={Jean Diestl},
   pdftitle={Linux namespaces},
   pdfsubject={KIT testing OS Level Virtualization},
   pdfkeywords={Papers, Template}
]{hyperref}

\begin{document}

\title{Linux Namespaces: KIT testing OS Level Virtualization}

\newcommand{\todo}[1]{{\texttt{[#1]}}}
\newcommand{\code}[1]{{\tt \small{#1}}}

\maketitle
%\draftfooter

\begin{abstract}
While all operating systems virtualize hardware like memory or the cpu other resources remain shared between processes.
In kernel 2.4.19 linux introduced the concept of namespaces to virtualize such resources. This paper will give a brief 
introduction to linux namespaces and present KIT a tool that was developed by Congyu Liu et al. to
find bugs in those.
\end{abstract}

\section{Introduction}\label{sec:introduction}
Linux namespaces are a kernel feature that allows process isolation on the operating system level.
This allows to virtualize resources like the network stack or the process tree.
While processes in the same namespace see the modifications their peers made to system resources
processes in other namespaces do not. Unlike similar technologies namespaces were isolated with
isolation in mind. 
This feature is widely used and builds the foundation for many container technologies like podman.
KIT is a new framework developed by Congyu Liu et al. for finding interference bugs in OS level virtualization\cite{0}. 
This is done by comparing systemcall traces of processes with and without possible interference.
This report gives an brief introduction to the inner
workings of  KIT and will also give a detailed description of one bug
that was found by KIT. 

\section{Linux Namespaces}\label{sec:background}

\subsection{usecases}
Containers create an reproducible enviroment that is independent from the host system with minimal overhead.
Thus software that is run inside a container is not affected if the host system is changed, 
Container engines like docker or podman achieve this by using namespaces and other isolation technologies to build this enviroments.


Another usecase for namespace is sandboxing. For example Chrome  and Firefox use linux namespaces in their sandboxes. 
Chrome uses user namespaces and PID namespaces to isolate certain processes.
This is done to reduce the impact of vulnerbilities in those processes that could lead to remote code exection.


\subsection{Inner workings}
Linux knows 7 namespaces: mount, PID, net, ipc, user, UTS and cgroup namespaces. Each namespace
isolates it's own set of resources. Namespaces are implemented in the linux kernel.
Each process has a link to the namespaces it belongs to. This link can be found in
/proc/self/ns\cite{8}. The namespaces are implemented as a tree. Each namespace has a parent and 
elements in child namespaces are visible in the parent namespace, there they can show different
attributes than in their respective child namespaces. For example a process in a pid namespace might 
believe that it is pid 1 while the pid in the parent namespace is 21 and the pid in the root namespace is 42.

Linux handels namespaces via inodes. Each namespace has a corresponding inode. Processes in this
namespace link to this inode. If no links to this inode exist anymore and thus no processes are in
this namespace the namespace is destroyed. To keep a namespace alive even with no processes in it
one can bind the corresponding file to another place in the filesystem. To reference a namespace a
filedescriptor is used. The namespaces are managed by the kernel processes can use various system
calls to create new namespaces or to join existing ones.\cite{8} Following is a list of the seven
namespaces and their features.


\subsection{Process ID namespace}
The PID namespace isolates the set of process id's. 
Thus each PID namespace has a full set of PID's to use in a new network namespace the pids start
with one.
Processes in different PID namespaces can have the same PID in their namespace. 
Processes that are spawned in a PID namespace get a PID in the parent PID namespace as well 
\cite{11}.

\subsection{Network namespaces}
Each net namespace has it's own network stack. There each net namespace has it's own set of ip's ,
firewall rules, routing tables and sockets. Physical network hardware is assigned to exaactly one
net namespace and can only used from within this namespace. Linux provides a virtual network device
pairs that can connect net namespaces.\cite{10}

\subsection{Mount namespaces}
Mount namespaces isolate the filesystem mount points. 
Each mount namespace provides a own view of the system mountpoints. 
Upon creating these views are copied from the parent or calling processes namespace.
To softe nthe impacts of isolation linux introduced shared subtrees. This allows the propagation of
mount and unmount events between namespaces.\cite{12}

\subsection{IPC namespaces}
IPC namespaces isolates POSIX message queues and System V IPC objects. This allows the reuse of identifiers
in different namespaces.\cite{13}

\subsection{UTS namespaces}
UTS namespaces isolate the hostname and the domainname. Upon creation the hostname and domainname are copied from the parent namespace.\cite{14}

\subsection{Time namespaces}
Time namespaces isolate the system clock. This allows different offsets for different namespaces.
Unlike other namesapces this namespace can only be created via unshare and  the calling process is
not plaed inside the namespace.\cite{15}

\subsection{Cgroup namespaces}


\subsection{User namespaces}

\section{Related Technologies}\label{sec:related}
\subsection{chroot}
Linux knows the change root system call which changes the root directory of the calling
process. This means that the calling process and its children can not access files outside of the
new root. This is implemented in the pathname resolution\cite{1}. Chroots were not intended as
isolation technique and thus can be escaped sometimes. Linux mount namespaces are
designed as isolation tool and can achieve the same results as chroot. Besides that one can use
chroots in combination with mount namespaces. %TODO cite source for escape 

\subsection{SELinux and AppArmor}
SELinux and AppArmor are systems that allow the implementation of mandatory access control. In
contrast to the traditional linux access control this means that policies are enforced by the system
and can not be altered by the user. Furthermore these tools allow a more fine grained control over
access rights. This can be done to protect other processes and the system but does not allow the resource
virtualization that namespaces allow. %TODO cite source
\subsection{Windows containers}%TODO change name
Windows seems to have a similar concept to linux namespaces called process isolation. Not much is known about the
implementation. Additionally windows allows also so called hyper-v isolation, here each container
gets his own virtual machine and is run on the hypervisor\cite{3}.

\section{Namespace bug}\label{sec:background}
\subsection{Interference bugs}
Many bugs in the linux namespace implementation are semantic bugs. This means that the 
bug does not result in invaldi memory access or a crash but in wrong behavior. Functional interference bugs are
such bugs that allow processes to interfere with processes outside  of their namespace. Thus
breaking isolation. This bugs are hard to detect with traditional testing methods due to the
complexity of the bugs and the complexity of the kernel itself.
\section{Related Work}\label{sec:relwork} 
\section{KIT}
KIT is a new framework for finding interference bugs in OS level virtualization\cite{0}. It was
implements a new differential approach to finding such bugs and found 9 new bugs in kernel 5.13\cite{2}.
KIT is designed as pipeline and implemented in 7600 lines of code not counting existing tools\cite{0}.
The main idea behind KIT is to check if a process behaves differently if another process is running
in parallel.
\subsection{Testcase generation}
KIT takes as input a corpus of testcases these come from other kernel fuzzers.
A KIT testcase contains to programs, one which sender who modifies a namespace protected kernel
resouce and a reciever who reads from the same resource. To find such testcases
KIT runs the input testcases in a special environment and profiles their memory access. 
After that 2 programms are paired together if they access similar memory regions with a write and
read access and the memory region belongs to an namespace protected resouce.
To reduce the number of testcases uses heuristics to group similar testcases together.


\subsection{Testcase execution}
KIT uses Qemu to run testcases in virtual machines. To avoid non deterministic behavior KIT uses
a different communication channel and reloads vm snapshots after each testcase. KIT executes a
testcase twice. The first time first the sender program is run and then the reciever program. The
systemcall trace of the reciever is collected. In the second run the sender is skipped and the reciever
is run again to collect a baseline systemcall trace. 
\subsection{Bug detection}
KIT keeps these systemcall traces as Abstract Syntax Trees (AST). This additional information allows 
to create minimal testcases and to filter out irrelevant systemcalls. This is done by comparing the ASTs
recursivly and ignoring children that are flagged as irrelevant. These flags are typically set when
a systemcall involves resources that are not isolated by namespaces or if the output of the
systemcall is not static. This can be foundout by rerunning the reciever multiple times and
comparing the systemcall traces. Each inner node that differs in these AST's can be flagged as non
deterministic.
After a difference is found KIT creates a minimal by differntially removing systemcalls. This
minimal testcase is then passed to the next stage.
\subsection{report aggregation}
The last stage of KIT is the report aggregation. This stage is important since the results will be
analyzed by humans and thus need to be reduced to a minimum to save time. KIT does this by grouping
testcases together if they have the same sender and reciever systemcalls that are responsible for
the bug. 
\section{A namespace bug}\label{sec:bug}
\subsection{Bug description}
The paper found 9 new bugs in the linux kernel 5.13 \cite{0}. One of these bugs is a net namespace
bug that will be described in this section. 

\subsection{Network background}
Sockets are pseudo files that serve as endpoints for communication similar to pipes. Unlike pipes
they allow duplex communication and can allow communication over networks\cite{5}. Sockets are
used to implement network protocols in user space \cite{5}. The kernel forwards the packets to the
corresponding socket. This mapping can be seen in /proc/net/ptype \cite{6}. Linux sockets are
namespace protected and thus no information about them should be shared between namespaces.

\subsection{Bug description}
Packets that are bound to devices are only showed in the namespace of the device. However if packet
types are not bound to a device they have no reference to a namespace and are shown in all network
namespaces. This allows a process to create a packet type in a network namespace and a second
process can see this packet type in a different network namespace thus breaking isolation.
%Maybe code 
\subsection{Bug fix}
The fix for this bug is adding a pointer to the network namespace that references the namespace
where the packet type was created. This pointer is then check whenever the packet type is
viewed. A fix has been submitted.\cite{4}
\subsection{Impact}
This bug presents a minor information leakage and is merely relevant for desktop systems.
However in an shared host enviroment this bug allows two processes to check if they run on the same
hardware. This information can be used to perform power attacks. These attacks aim to create power
outages by creating power peaks in multiple hosts at the same time. If two containers share the same
host this knowledge can decrease the cost of such attacks\cite{7}.
\section{Conclusion}\label{sec:conclusion}

\bibliographystyle{abbrv}
\bibliography{template}
%\footnotesize
\end{document}
